#!/usr/bin/env python3
"""
Plot benchmark results from a summary CSV generated by orchestrate_benchmarks.sh.

Inputs:
  --summary: path to summary.csv (required)
  --out-dir: directory to write plots (required)

The CSV is expected to have columns:
transport,payload,rate,run_id,sub_tps,p50_ms,p95_ms,p99_ms,pub_tps,sent,recv,errors,artifacts_dir

Outputs:
  - throughput_vs_rate_payload<bytes>.png
  - p99_vs_rate_payload<bytes>.png
"""
import argparse
import csv
import os
import re
import sys
from collections import defaultdict


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser()
    p.add_argument("--summary", required=True, help="Path to summary.csv")
    p.add_argument("--out-dir", required=True, help="Output directory for plots")
    return p.parse_args()


def load_records(csv_path: str):
    recs = []
    with open(csv_path, newline="") as f:
        rd = csv.DictReader(f)
        for r in rd:
            try:
                recs.append(
                    {
                        "transport": r["transport"],
                        "payload": int(r["payload"]),
                        "rate": int(r["rate"]),
                        "sub_tps": float(r["sub_tps"]) if r["sub_tps"] else float("nan"),
                        "p99_ms": float(r["p99_ms"]) if r["p99_ms"] else float("nan"),
                    }
                )
            except Exception:
                # Skip malformed rows
                continue
    return recs


def unique_sorted(seq):
    return sorted(set(seq))


def main() -> int:
    args = parse_args()
    os.makedirs(args.out_dir, exist_ok=True)

    # Matplotlib availability
    try:
        import matplotlib.pyplot as plt  # type: ignore
    except Exception as e:
        print(f"[plot] matplotlib not available: {e}\nInstall with: pip install matplotlib", file=sys.stderr)
        return 0

    records = load_records(args.summary)
    if not records:
        print("[plot] no records to plot", file=sys.stderr)
        return 0

    payloads = unique_sorted(r["payload"] for r in records)
    rates = unique_sorted(r["rate"] for r in records)
    transports = unique_sorted(r["transport"] for r in records)

    by_pt = defaultdict(list)
    for r in records:
        by_pt[(r["payload"], r["transport"])].append(r)

    # Throughput vs offered rate
    for payload in payloads:
        fig, ax = plt.subplots(figsize=(7, 4))
        for t in transports:
            xs, ys = [], []
            # Preserve input order of rates on X axis
            for rate in rates:
                vals = [r for r in by_pt[(payload, t)] if r["rate"] == rate]
                if not vals:
                    continue
                xs.append(rate)
                ys.append(vals[0]["sub_tps"])
            if xs:
                ax.plot(xs, ys, marker="o", label=t)
        ax.set_title(f"Throughput vs Offered Rate (payload={payload}B)")
        ax.set_xlabel("Offered rate (msg/s)")
        ax.set_ylabel("Delivered throughput (msg/s)")
        ax.grid(True, alpha=0.3)
        ax.legend()
        fig.tight_layout()
        fig.savefig(os.path.join(args.out_dir, f"throughput_vs_rate_payload{payload}.png"), dpi=150)
        plt.close(fig)

    # P99 vs offered rate
    for payload in payloads:
        fig, ax = plt.subplots(figsize=(7, 4))
        for t in transports:
            xs, ys = [], []
            for rate in rates:
                vals = [r for r in by_pt[(payload, t)] if r["rate"] == rate]
                if not vals:
                    continue
                xs.append(rate)
                ys.append(vals[0]["p99_ms"])
            if xs:
                ax.plot(xs, ys, marker="o", label=t)
        ax.set_title(f"P99 latency vs Offered Rate (payload={payload}B)")
        ax.set_xlabel("Offered rate (msg/s)")
        ax.set_ylabel("P99 latency (ms)")
        ax.grid(True, alpha=0.3)
        ax.legend()
        fig.tight_layout()
        fig.savefig(os.path.join(args.out_dir, f"p99_vs_rate_payload{payload}.png"), dpi=150)
        plt.close(fig)

    # Fanout plots: x = subscriber count, y = delivered throughput, per (payload, rate)
    fanout_rows = []
    subs_pat = re.compile(r"-s(\d+)$")
    for r in records:
        t = r["transport"]
        if t.startswith("fanout-"):
            m = subs_pat.search(t)
            if not m:
                continue
            try:
                subs = int(m.group(1))
            except Exception:
                continue
            fanout_rows.append({
                "payload": r["payload"],
                "rate": r["rate"],
                "subs": subs,
                "sub_tps": r["sub_tps"],
                "label": t.rsplit("-s", 1)[0],
            })

    if fanout_rows:
        by_pr = defaultdict(list)  # (payload, rate) -> rows
        for r in fanout_rows:
            by_pr[(r["payload"], r["rate"])].append(r)
        for (payload, rate), rows in by_pr.items():
            # Group by label in case multiple fanout transport flavors exist
            by_label = defaultdict(list)
            for rr in rows:
                by_label[rr["label"]].append(rr)

            fig, ax = plt.subplots(figsize=(7, 4))
            for label, lst in by_label.items():
                lst = sorted(lst, key=lambda x: x["subs"])
                xs = [x["subs"] for x in lst]
                ys = [x["sub_tps"] for x in lst]
                ax.plot(xs, ys, marker="o", label=label)
            ax.set_title(f"Delivered throughput vs Fanout (payload={payload}B, rate={rate}/s)")
            ax.set_xlabel("Fanout (subscribers)")
            ax.set_ylabel("Delivered throughput (msg/s)")
            ax.grid(True, alpha=0.3)
            ax.legend()
            fig.tight_layout()
            fig.savefig(os.path.join(args.out_dir, f"fanout_throughput_payload{payload}_rate{rate}.png"), dpi=150)
            plt.close(fig)

    print("[plot] Wrote plots to", args.out_dir)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
