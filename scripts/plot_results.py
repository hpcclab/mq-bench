#!/usr/bin/env python3
"""
Plot benchmark results from a summary CSV generated by orchestrate_benchmarks.sh.

Inputs:
  --summary: path to summary.csv (required)
  --out-dir: directory to write plots (required)

The CSV is expected to have columns:
transport,payload,rate,run_id,sub_tps,p50_ms,p95_ms,p99_ms,pub_tps,sent,recv,errors,artifacts_dir

Outputs:
  - throughput_vs_rate_payload<bytes>.png
  - p99_vs_rate_payload<bytes>.png
"""
import argparse
import csv
import os
import sys
from collections import defaultdict


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser()
    p.add_argument("--summary", required=True, help="Path to summary.csv")
    p.add_argument("--out-dir", required=True, help="Output directory for plots")
    return p.parse_args()


def load_records(csv_path: str):
    recs = []
    with open(csv_path, newline="") as f:
        rd = csv.DictReader(f)
        for r in rd:
            try:
                recs.append(
                    {
                        "transport": r["transport"],
                        "payload": int(r["payload"]),
                        "rate": int(r["rate"]),
                        "sub_tps": float(r["sub_tps"]) if r["sub_tps"] else float("nan"),
                        "p99_ms": float(r["p99_ms"]) if r["p99_ms"] else float("nan"),
                    }
                )
            except Exception:
                # Skip malformed rows
                continue
    return recs


def unique_sorted(seq):
    return sorted(set(seq))


def main() -> int:
    args = parse_args()
    os.makedirs(args.out_dir, exist_ok=True)

    # Matplotlib availability
    try:
        import matplotlib.pyplot as plt  # type: ignore
    except Exception as e:
        print(f"[plot] matplotlib not available: {e}\nInstall with: pip install matplotlib", file=sys.stderr)
        return 0

    records = load_records(args.summary)
    if not records:
        print("[plot] no records to plot", file=sys.stderr)
        return 0

    payloads = unique_sorted(r["payload"] for r in records)
    rates = unique_sorted(r["rate"] for r in records)
    transports = unique_sorted(r["transport"] for r in records)

    by_pt = defaultdict(list)
    for r in records:
        by_pt[(r["payload"], r["transport"])].append(r)

    # Throughput vs offered rate
    for payload in payloads:
        fig, ax = plt.subplots(figsize=(7, 4))
        for t in transports:
            xs, ys = [], []
            # Preserve input order of rates on X axis
            for rate in rates:
                vals = [r for r in by_pt[(payload, t)] if r["rate"] == rate]
                if not vals:
                    continue
                xs.append(rate)
                ys.append(vals[0]["sub_tps"])
            if xs:
                ax.plot(xs, ys, marker="o", label=t)
        ax.set_title(f"Throughput vs Offered Rate (payload={payload}B)")
        ax.set_xlabel("Offered rate (msg/s)")
        ax.set_ylabel("Delivered throughput (msg/s)")
        ax.grid(True, alpha=0.3)
        ax.legend()
        fig.tight_layout()
        fig.savefig(os.path.join(args.out_dir, f"throughput_vs_rate_payload{payload}.png"), dpi=150)
        plt.close(fig)

    # P99 vs offered rate
    for payload in payloads:
        fig, ax = plt.subplots(figsize=(7, 4))
        for t in transports:
            xs, ys = [], []
            for rate in rates:
                vals = [r for r in by_pt[(payload, t)] if r["rate"] == rate]
                if not vals:
                    continue
                xs.append(rate)
                ys.append(vals[0]["p99_ms"])
            if xs:
                ax.plot(xs, ys, marker="o", label=t)
        ax.set_title(f"P99 latency vs Offered Rate (payload={payload}B)")
        ax.set_xlabel("Offered rate (msg/s)")
        ax.set_ylabel("P99 latency (ms)")
        ax.grid(True, alpha=0.3)
        ax.legend()
        fig.tight_layout()
        fig.savefig(os.path.join(args.out_dir, f"p99_vs_rate_payload{payload}.png"), dpi=150)
        plt.close(fig)

    print("[plot] Wrote plots to", args.out_dir)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
