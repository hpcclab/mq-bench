#!/usr/bin/env python3
"""
Plot benchmark results from a summary CSV generated by orchestrate_benchmarks.sh.

Inputs:
  --summary: path to summary.csv (required)
  --out-dir: directory to write plots (required)

The CSV is expected to have columns:
transport,payload,rate,run_id,sub_tps,p50_ms,p95_ms,p99_ms,pub_tps,sent,recv,errors,artifacts_dir

Outputs:
    - throughput_vs_rate_payload<bytes>.png
    - p99_vs_rate_payload<bytes>.png
    - fanout_throughput_payload<bytes>_rate<r>.png (if fanout rows exist)
    - gallery.md (Markdown file embedding all figures)
"""
import argparse
import csv
import os
import math
import re
import sys
from collections import defaultdict


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser()
    p.add_argument("--summary", required=True, help="Path to summary.csv")
    p.add_argument("--out-dir", required=True, help="Output directory for plots")
    return p.parse_args()


def load_records(csv_path: str):
    recs = []
    with open(csv_path, newline="") as f:
        rd = csv.DictReader(f)
        for r in rd:
            try:
                recs.append(
                    {
                        "transport": r["transport"],
                        "payload": int(r["payload"]),
                        "rate": int(r["rate"]),
                        "sub_tps": float(r["sub_tps"]) if r["sub_tps"] else float("nan"),
                        "p99_ms": float(r["p99_ms"]) if r["p99_ms"] else float("nan"),
                    }
                )
            except Exception:
                # Skip malformed rows
                continue
    return recs


def unique_sorted(seq):
    return sorted(set(seq))


def main() -> int:
    args = parse_args()
    os.makedirs(args.out_dir, exist_ok=True)

    # Matplotlib availability
    try:
        import matplotlib.pyplot as plt  # type: ignore
    except Exception as e:
        print(f"[plot] matplotlib not available: {e}\nInstall with: pip install matplotlib", file=sys.stderr)
        return 0

    records = load_records(args.summary)
    if not records:
        print("[plot] no records to plot", file=sys.stderr)
        return 0

    payloads = unique_sorted(r["payload"] for r in records)
    transports = unique_sorted(r["transport"] for r in records)

    # For rate-based plots, ignore fanout runs and any rows with non-positive rate or NaN metrics
    rate_records = [
        r for r in records
        if not str(r["transport"]).startswith("fanout-")
           and (r["rate"] or 0) > 0
           and math.isfinite(r.get("sub_tps", float("nan")))
    ]
    rates = unique_sorted(r["rate"] for r in rate_records)

    by_pt = defaultdict(list)
    for r in rate_records:
        by_pt[(r["payload"], r["transport"])].append(r)

    # Track images to build a markdown gallery at the end
    throughput_imgs = {}
    p99_imgs = {}
    fanout_imgs = {}  # (payload, rate) -> filename

    # Throughput vs offered rate
    for payload in payloads:
        fig, ax = plt.subplots(figsize=(7, 4))
        for t in transports:
            xs, ys = [], []
            # Preserve input order of rates on X axis
            for rate in rates:
                vals = [r for r in by_pt[(payload, t)] if r["rate"] == rate]
                if not vals:
                    continue
                xs.append(rate)
                ys.append(vals[0]["sub_tps"])
            if xs:
                ax.plot(xs, ys, marker="o", label=t)
        ax.set_title(f"Throughput vs Offered Rate (payload={payload}B)")
        ax.set_xlabel("Offered rate (msg/s)")
        ax.set_ylabel("Delivered throughput (msg/s)")
        ax.grid(True, alpha=0.3)
        ax.legend()
        fig.tight_layout()
    fn = os.path.join(args.out_dir, f"throughput_vs_rate_payload{payload}.png")
    fig.savefig(fn, dpi=150)
    throughput_imgs[payload] = os.path.basename(fn)
    plt.close(fig)

    # P99 vs offered rate
    for payload in payloads:
        fig, ax = plt.subplots(figsize=(7, 4))
        for t in transports:
            xs, ys = [], []
            for rate in rates:
                vals = [r for r in by_pt[(payload, t)] if r["rate"] == rate]
                if not vals:
                    continue
                xs.append(rate)
                p99 = vals[0]["p99_ms"]
                if not math.isfinite(p99):
                    continue
                ys.append(p99)
            if xs:
                ax.plot(xs, ys, marker="o", label=t)
        ax.set_title(f"P99 latency vs Offered Rate (payload={payload}B)")
        ax.set_xlabel("Offered rate (msg/s)")
        ax.set_ylabel("P99 latency (ms)")
        ax.grid(True, alpha=0.3)
        ax.legend()
        fig.tight_layout()
    fn = os.path.join(args.out_dir, f"p99_vs_rate_payload{payload}.png")
    fig.savefig(fn, dpi=150)
    p99_imgs[payload] = os.path.basename(fn)
    plt.close(fig)

    # Fanout plots: x = subscriber count, y = delivered throughput, per (payload, rate)
    fanout_rows = []
    subs_pat = re.compile(r"-s(\d+)$")
    for r in records:
        t = r["transport"]
        if t.startswith("fanout-"):
            m = subs_pat.search(t)
            if not m:
                continue
            try:
                subs = int(m.group(1))
            except Exception:
                continue
            fanout_rows.append({
                "payload": r["payload"],
                "rate": r["rate"],
                "subs": subs,
                "sub_tps": r["sub_tps"],
                # Normalize label e.g. fanout-mqtt-hivemq-s8 -> fanout-mqtt-hivemq
                "label": t[: t.rfind("-s")],
            })

    if fanout_rows:
        by_pr = defaultdict(list)  # (payload, rate) -> rows
        for r in fanout_rows:
            by_pr[(r["payload"], r["rate"])].append(r)
        for (payload, rate), rows in by_pr.items():
            # Group by label in case multiple fanout transport flavors exist
            by_label = defaultdict(list)
            for rr in rows:
                by_label[rr["label"]].append(rr)

            fig, ax = plt.subplots(figsize=(7, 4))
            for label, lst in by_label.items():
                lst = sorted(lst, key=lambda x: x["subs"])
                xs = [x["subs"] for x in lst if math.isfinite(x.get("sub_tps", float("nan")))]
                ys = [x["sub_tps"] for x in lst if math.isfinite(x.get("sub_tps", float("nan")))]
                ax.plot(xs, ys, marker="o", label=label)
            ax.set_title(f"Delivered throughput vs Fanout (payload={payload}B, rate={rate}/s)")
            ax.set_xlabel("Fanout (subscribers)")
            ax.set_ylabel("Delivered throughput (msg/s)")
            ax.grid(True, alpha=0.3)
            ax.legend()
            fig.tight_layout()
            fn = os.path.join(args.out_dir, f"fanout_throughput_payload{payload}_rate{rate}.png")
            fig.savefig(fn, dpi=150)
            fanout_imgs[(payload, rate)] = os.path.basename(fn)
            plt.close(fig)

    # Build a simple markdown gallery
    try:
        md_path = os.path.join(args.out_dir, "README.md")
        with open(md_path, "w", encoding="utf-8") as f:
            f.write("# Benchmark plots\n\n")
            f.write(f"- Summary: `{os.path.abspath(args.summary)}`\n\n")

            # Table of contents
            f.write("## Table of contents\n\n")
            if throughput_imgs:
                f.write("- [Throughput vs Offered Rate](#throughput-vs-offered-rate)\n")
            if p99_imgs:
                f.write("- [P99 latency vs Offered Rate](#p99-latency-vs-offered-rate)\n")
            if fanout_imgs:
                f.write("- [Fanout: Delivered throughput](#fanout-delivered-throughput)\n")
            f.write("\n")

            if throughput_imgs:
                f.write("## Throughput vs Offered Rate\n\n")
                for payload in payloads:
                    img = throughput_imgs.get(payload)
                    if not img:
                        continue
                    f.write(f"### payload={payload}B\n\n")
                    f.write(f"![throughput payload {payload}]({img})\n\n")

            if p99_imgs:
                f.write("## P99 latency vs Offered Rate\n\n")
                for payload in payloads:
                    img = p99_imgs.get(payload)
                    if not img:
                        continue
                    f.write(f"### payload={payload}B\n\n")
                    f.write(f"![p99 payload {payload}]({img})\n\n")

            if fanout_imgs:
                f.write("## Fanout: Delivered throughput\n\n")
                # Group by payload, then rate for consistent order
                pr_keys = sorted(fanout_imgs.keys())
                by_p = defaultdict(list)
                for (p, r) in pr_keys:
                    by_p[p].append(r)
                for p in sorted(by_p.keys()):
                    f.write(f"### payload={p}B\n\n")
                    for r in sorted(set(by_p[p])):
                        img = fanout_imgs.get((p, r))
                        if not img:
                            continue
                        f.write(f"#### rate={r}/s\n\n")
                        f.write(f"![fanout p{p} r{r}]({img})\n\n")

        print("[plot] Wrote plots to", args.out_dir)
        print("[plot] Wrote gallery:", md_path)
    except Exception as e:
        print(f"[plot] failed to write README.md: {e}", file=sys.stderr)
        print("[plot] Wrote plots to", args.out_dir)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
